# Student agent: Add your own agent here
from agents.agent import Agent
from store import register_agent
#import sys
from time import time
from random import choice
from math import sqrt, log
from copy import deepcopy
#from operator import attrgetter
import numpy as np



class Node:
    """
    Nodes of a tree that will contain states of the game.
    
    Parameters:
    -----------
        state
            a given state of the game
        parent
            the parent node of the current node
        children
            a list of child nodes of the current node
    """
    def __init__(self, state, parent, *children):
        self.state = state
        self.parent = parent
        self.children = list(children)
        
        
    # set the state of a node
    def set_state(self, state):
        self.state = state
        
        
    # set the parent of a node
    def set_parent(self, parent):
        self.parent = parent
        
        
    # set the children of a node
    def set_children(self, children):
        self.children = children
        
        
    # add a child to the child nodes
    def add_child(self, child):
        self.children.append(child)
        
        
    # return a random child in the child nodes
    def get_random_child(self):
        return choice(self.children)
    
    
    # return the child node with the most visits (for the final move)
    # in case of a tie, the first child with the max value is chosen
    def get_best_child(self):
        best_child = None
        most_visits = -1
        
        for c in self.children:
            visits = c.state.visit_count
            if visits > most_visits:
                most_visits = visits
                best_child = c
        
        return best_child
    

class Tree:
    """
    A tree that will contain states of the game.
    
    Parameters:
    -----------
        root
            the root node of the tree
    """
    def __init__(self, root):
        self.root = root
        
        
    # set the root of the tree
    def set_root(self, root):
        self.root = root
      
        
    # add a child node to a parent (might not be necessary)
    def add_child(self, parent, child):
        parent.children.append(child)
       
        
class State:
    """
    A current state of the game.
    Unfortunately, it required some of the functions from the original 'world.py'.
    
    Parameters:
        player_num
            the player who can move in the current state
        visit_count
            the number of visits to the node with this state
        win_count
            the number of win conditions generated by this state
        chess_board
            the outline of the board in the current state
        my_pos
            the position of the current player
        adv_pos
            the position of the current adversary
        max_step
            the maximum number of steps that the current player can take
        moves
            the set of possible moves for a single step (fixed)
        opposites
            the table of opposing directions (fixed)
        board_size
            the size of the board (fixed, for the current game)
    """
    def __init__(self, player_num, visit_count, win_count, chess_board, my_pos, adv_pos, max_step, dir):
        self.player_num = player_num
        self.visit_count = visit_count
        self.win_count = win_count
        self.chess_board = chess_board
        self.my_pos = my_pos
        self.adv_pos = adv_pos
        self.max_step = max_step
        self.dir = dir
        
        # moves (up, right, down, left)
        self.moves = ((-1, 0), (0, 1), (1, 0), (0, -1))
        # opposite directions
        self.opposites = {0: 2, 1: 3, 2: 0, 3: 1}
        # size of the board
        self.board_size = len(self.chess_board[0])
        
        
    # ALL SETTER FUNCTIONS (some are not necessary)
    
    def set_player_num(self, player_num):
        self.player_num = player_num
        
        
    def set_visits(self, visit_count):
        self.visit_count = visit_count
        
        
    def set_score(self, win_count):
        self.win_count = win_count
        
        
    def set_board(self, chess_board):
        self.chess_board = chess_board
        
        
    def set_my_pos(self, my_pos):
        self.my_pos = my_pos
        
        
    def set_adv_pos(self, adv_pos):
        self.adv_pos = adv_pos
        
        
    def set_max_step(self, max_step):
        self.max_step = max_step
        
        
    def set_dir(self, dir):
        self.dir = dir
        
        
    def set_board_size(self, board_size):
        self.board_size = board_size
        
        
    # increment the visit count by 1
    # not necessary, but helps with identification
    def increment_visits(self):
        self.visit_count += 1
        
        
    # increment the win count by 1
    # this can be adjusted to be other things, like how many squares you won
    def increment_score(self):
        if self.win_count >= 0:
            self.win_count += 10
       
    
    # return the player number of the current adversary
    def get_opponent(self):
        return (1 - self.player_num) % 2
    
    
    # switch the current player to the current adversary
    def toggle_opponent(self):
        self.player_num = (1 - self.player_num) % 2
        
    """
    NOTE: The following functions are modified from 'world.py'.
    If there are more economical algorithms, feel free to put them here.
    """
    
    # simulate a random movement on the current player
    def random_walk(self, my_pos, adv_pos):
        # copy the original position
        ori_pos = deepcopy(my_pos)
        steps = np.random.randint(0, self.max_step + 1)
        
        for _ in range(steps):
            r, c = my_pos
            dir = np.random.randint(0, 4)
            m_r, m_c = self.moves[dir]
            # take one step
            my_pos = (r + m_r, c + m_c)

            k = 0
            # if i am hitting a barrier or on top of my adversary
            while self.chess_board[r, c, dir] or my_pos == adv_pos:
                k += 1
                # the limit of adjustments (adjust this number and the one below for time)
                if k > 100:
                    break
                # find another direction to place a barrier
                dir = np.random.randint(0, 4)
                m_r, m_c = self.moves[dir]
                # find a new step to take
                my_pos = (r + m_r, c + m_c)

            # if we hit the limit, don't move
            if k > 100:
                my_pos = ori_pos
                break

        # place barrier
        dir = np.random.randint(0, 4)
        r, c = my_pos
        # if i am hitting a barrier
        while self.chess_board[r, c, dir]:
            # find another direction to place a barrier
            dir = np.random.randint(0, 4)

        return my_pos, dir
        
    
    # check if the game has reached a final state
    def check_endgame(self):
        # Union-Find
        father = dict()
        for r in range(self.board_size):
            for c in range(self.board_size):
                father[(r, c)] = (r, c)

        def find(pos):
            if father[pos] != pos:
                father[pos] = find(father[pos])
            return father[pos]

        def union(pos1, pos2):
            father[pos1] = pos2

        # i barely understand any of this
        for r in range(self.board_size):
            for c in range(self.board_size):
                for dir, move in enumerate(
                    self.moves[1:3]
                ):  # Only check down and right
                    if self.chess_board[r, c, dir + 1]:
                        continue
                    pos_a = find((r, c))
                    pos_b = find((r + move[0], c + move[1]))
                    if pos_a != pos_b:
                        union(pos_a, pos_b)

        for r in range(self.board_size):
            for c in range(self.board_size):
                find((r, c))
        
        if self.player_num == 1:
            my_r = find(self.adv_pos)
            adv_r = find(self.my_pos)
        elif self.player_num == 0:
            my_r = find(self.my_pos)
            adv_r = find(self.adv_pos)
        my_score = list(father.values()).count(my_r)
        adv_score = list(father.values()).count(adv_r)
        
        # the game has not finished
        if my_r == adv_r:
            return 2
            #return 2, my_score

        # i have more squares than the adversary
        if my_score > adv_score:
            return 0
            #return 1, my_score
        # i have less squares than the adversary
        elif my_score < adv_score:
            return 1
            #return -1, my_score
        # i tied with the adversary
        else:
            return 0
            #return 0, my_score
 
    
    # check if i have hit a boundary
    def check_boundary(self, pos):
        r, c = pos
        return 0 <= r < self.board_size and 0 <= c < self.board_size
       
    
    # check if the step i am taking is an acceptable step
    def check_valid_step(self, start_pos, end_pos, barrier_dir):
        # get the coordinates for the start and end position
        r, c = end_pos
        
        # reject the step if there is already a barrier placed
        if self.chess_board[r, c, barrier_dir]:
            return False
        # accept the step if there is no barrier placed and you did not move
        if np.array_equal(start_pos, end_pos):
            return True
        
        # get position of the adversary
        adv_pos = self.my_pos

        # BFS
        state_queue = [(start_pos, 0)]
        visited = {tuple(start_pos)}
        is_reached = False
        while state_queue and not is_reached:
            cur_pos, cur_step = state_queue.pop(0)
            r, c = cur_pos
            if cur_step == self.max_step:
                break
            for dir, move in enumerate(self.moves):
                if self.chess_board[r, c, dir]:
                    continue

                next_pos = cur_pos + move
                if np.array_equal(next_pos, adv_pos) or tuple(next_pos) in visited:
                    continue
                if np.array_equal(next_pos, end_pos):
                    is_reached = True
                    break

                visited.add(tuple(next_pos))
                state_queue.append((next_pos, cur_step + 1))

        # return whether or not 'end' can be reached from 'start'
        return is_reached


    # place a barrier
    def set_barrier(self, chess_board, r, c, dir):
        # set the barrier to True
        chess_board[r, c, dir] = True
        # set the opposite barrier to True
        move = self.moves[dir]
        chess_board[r + move[0], c + move[1], self.opposites[dir]] = True
  
    
    # get all valid moves for the current position
    def get_all_possible_moves(self):
        possible_moves = []
        
        for i in range(self.board_size + 1):
            for j in range(self.board_size + 1):
                next_pos = (i, j)
                # the position does not hit a boundary
                if self.check_boundary(next_pos):
                    for dir in range(4):
                        # the move is valid
                        start_array = np.asarray(self.adv_pos)
                        end_array = np.asarray(next_pos)
                        if self.check_valid_step(start_array, end_array, dir):
                            possible_moves.append((i, j, dir))
        #print(possible_moves)                
        return possible_moves
    
    
    # return a set of states for all valid moves for the current position
    def get_all_possible_states(self):
        possible_states = []
        possible_moves = self.get_all_possible_moves()
        
        for move in possible_moves:
            i, j, dir = move
            # create a new board which is the result of performing the move
            new_chess_board = deepcopy(self.chess_board)
            self.set_barrier(new_chess_board, i, j, dir)
            # swap the player and adversary in the next state
            s = State(self.get_opponent(), 0, 0, new_chess_board, (i, j), self.my_pos, self.max_step, dir)
            # add the new state to possible states
            possible_states.append(s)

        return possible_states
     
      
    # make a random move
    # NOTE: we are not swapping players because this function is used in 'MonteCarloTreeSearch'
    def random_play(self):
        my_new_pos, dir = self.random_walk(self.my_pos, self.adv_pos)
        i, j = my_new_pos
        self.set_barrier(self.chess_board, i, j, dir)
        self.my_pos = self.adv_pos
        self.adv_pos = (i, j)


class MonteCarloTreeSearch:
    """
    Where the magic happens.
    An instance of the entire search tree and search algorithm
    leading to a final outcome.
    """
    def __init__(self):
        pass
    
    
    class UCT:
        """
        Implementation of the upper confidence tree.
        """
        def __init__(self):
            pass
        
        
        # return the UCT value of a given node
        # the value 'c' is adjustable (default sqrt(2))
        def get_uct_value(self, total_visits, node_wins, node_visits, c=1.41):
            # invalid UCT
            if node_visits == 0:
                return float('inf')

            return (node_wins / node_visits) + c * sqrt(log(total_visits) / node_visits)


        # find the node with the highest UCT value
        def find_best_node(self, node):
            best_child = None
            best_uct = -1
            parent_visits = node.state.visit_count
            
            for c in node.children:
                uct = self.get_uct_value(parent_visits, c.state.win_count, c.state.visit_count)
                
                if uct > best_uct:
                    best_uct = uct
                    best_child = c
            
            return best_child

        
    # select the most promising node from the root with current UCT values
    def select_promising_node(self, root):
        node = root
        UCT = self.UCT()
        while len(node.children) != 0:
            node = UCT.find_best_node(node)
        
        return node
    
    
    # expand a node and its states
    def expand_node(self, node):
        possible_states = node.state.get_all_possible_states()
        
        for state in possible_states:
            new_node = Node(state, node)
            new_node.state.set_player_num(node.state.get_opponent())
            node.add_child(new_node)
      
        
    # propagate a value up the tree
    def backpropagate(self, node, player_num):
        temp = node
        while temp is not None:
            temp.state.increment_visits()
            if temp.state.player_num == player_num and temp.state.player_num == 0:
                temp.state.increment_score()
                
            temp = temp.parent
    
    
    # simulate a full randomized game from the given state
    def simulate_random_playout(self, node):
        temp = deepcopy(node)
        temp_state = temp.state
        # check the final result of the simulated game
        board_status = temp_state.check_endgame()
        
        # if the opponent won, set a penalty score
        if board_status == 1:
            temp.parent.state.set_score(float('-inf'))
            return board_status
        
        # if the game is still ongoing, make another move
        while board_status == 2:
            temp_state.toggle_opponent()
            temp_state.random_play()
            board_status = temp_state.check_endgame()
        
        return board_status
    
    
    def find_next_move(self, current_board, player_num, my_pos, adv_pos, max_step, run_length=1.9):
        """
        Given information on the state of the game,
        we run a randomized simulation and return the state
        with the suggested highest win rate.

        Parameters
        ----------
            current_board
                the current board
            player_num
                the player who is currently being considered
            my_pos, adv_pos, max_step
                taken from the 'step' function in 'world.py'
            run_length
                how long the simulation can run for
        """
        opponent = (1 - player_num) % 2
        
        # set up the root node and tree (i may have to modify this)
        root_state = State(opponent, 0, 0, current_board, adv_pos, my_pos, max_step, 0)
        root_node = Node(root_state, None)
        tree = Tree(root_node)

        start = time()
        while time() - start < run_length:
            # SELECTION
            promising_node = self.select_promising_node(tree.root)
            board_status = promising_node.state.check_endgame()
            
            # EXPANSION
            if board_status == 2:
                self.expand_node(promising_node)
                
            # SIMULATION
            node_to_explore = promising_node
            if len(promising_node.children) > 0:
                node_to_explore = promising_node.get_random_child()
                
            result = self.simulate_random_playout(node_to_explore)
            
            # UPDATE
            self.backpropagate(node_to_explore, result)
            
        # get the node with the best score
        winner_node = root_node.get_best_child()
        # move 'into' the node for the next round
        tree.set_root(winner_node)
        
        return winner_node.state


@register_agent("student_agent")
class StudentAgent(Agent):
    def __init__(self):
        # inherit methods from superclass
        super(StudentAgent, self).__init__()
        # the current 'iteration' of the game
        self.turn = 0
        self.name = "ShallowBlue"
        # unneeded?
        self.dir_map = {
            "u": 0,
            "r": 1,
            "d": 2,
            "l": 3,
        }


    def step(self, chess_board, my_pos, adv_pos, max_step):
        # always load the current agent as '0' (first player)
        init_player_num = 0
        MCTS = MonteCarloTreeSearch()
        
        # if it is the agent's first turn, run 30 seconds
        if self.turn == 0:
            state = MCTS.find_next_move(chess_board, init_player_num, my_pos, adv_pos, max_step, 29.9)
            self.turn += 1
        # if it is any turn after the first, run 2 seconds
        else:
            state = MCTS.find_next_move(chess_board, init_player_num, my_pos, adv_pos, max_step)
            self.turn += 1
                
        return state.my_pos, state.dir
            